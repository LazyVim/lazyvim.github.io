"use strict";(self.webpackChunklazyvim=self.webpackChunklazyvim||[]).push([[9454],{3905:(n,e,t)=>{t.d(e,{Zo:()=>u,kt:()=>f});var a=t(7294);function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function r(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function s(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?r(Object(t),!0).forEach((function(e){i(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function o(n,e){if(null==n)return{};var t,a,i=function(n,e){if(null==n)return{};var t,a,i={},r=Object.keys(n);for(a=0;a<r.length;a++)t=r[a],e.indexOf(t)>=0||(i[t]=n[t]);return i}(n,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(a=0;a<r.length;a++)t=r[a],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(i[t]=n[t])}return i}var l=a.createContext({}),c=function(n){var e=a.useContext(l),t=e;return n&&(t="function"==typeof n?n(e):s(s({},e),n)),t},u=function(n){var e=c(n.components);return a.createElement(l.Provider,{value:e},n.children)},d="mdxType",p={inlineCode:"code",wrapper:function(n){var e=n.children;return a.createElement(a.Fragment,{},e)}},m=a.forwardRef((function(n,e){var t=n.components,i=n.mdxType,r=n.originalType,l=n.parentName,u=o(n,["components","mdxType","originalType","parentName"]),d=c(t),m=i,f=d["".concat(l,".").concat(m)]||d[m]||p[m]||r;return t?a.createElement(f,s(s({ref:e},u),{},{components:t})):a.createElement(f,s({ref:e},u))}));function f(n,e){var t=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var r=t.length,s=new Array(r);s[0]=m;var o={};for(var l in e)hasOwnProperty.call(e,l)&&(o[l]=e[l]);o.originalType=n,o[d]="string"==typeof n?n:i,s[1]=o;for(var c=2;c<r;c++)s[c]=t[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},5162:(n,e,t)=>{t.d(e,{Z:()=>s});var a=t(7294),i=t(6010);const r="tabItem_Ymn6";function s(n){let{children:e,hidden:t,className:s}=n;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(r,s),hidden:t},e)}},4866:(n,e,t)=>{t.d(e,{Z:()=>w});var a=t(7462),i=t(7294),r=t(6010),s=t(2466),o=t(6550),l=t(1980),c=t(7392),u=t(12);function d(n){return function(n){return i.Children.map(n,(n=>{if(!n||(0,i.isValidElement)(n)&&function(n){const{props:e}=n;return!!e&&"object"==typeof e&&"value"in e}(n))return n;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof n.type?n.type:n.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(n).map((n=>{let{props:{value:e,label:t,attributes:a,default:i}}=n;return{value:e,label:t,attributes:a,default:i}}))}function p(n){const{values:e,children:t}=n;return(0,i.useMemo)((()=>{const n=e??d(t);return function(n){const e=(0,c.l)(n,((n,e)=>n.value===e.value));if(e.length>0)throw new Error(`Docusaurus error: Duplicate values "${e.map((n=>n.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(n),n}),[e,t])}function m(n){let{value:e,tabValues:t}=n;return t.some((n=>n.value===e))}function f(n){let{queryString:e=!1,groupId:t}=n;const a=(0,o.k6)(),r=function(n){let{queryString:e=!1,groupId:t}=n;if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:e,groupId:t});return[(0,l._X)(r),(0,i.useCallback)((n=>{if(!r)return;const e=new URLSearchParams(a.location.search);e.set(r,n),a.replace({...a.location,search:e.toString()})}),[r,a])]}function g(n){const{defaultValue:e,queryString:t=!1,groupId:a}=n,r=p(n),[s,o]=(0,i.useState)((()=>function(n){let{defaultValue:e,tabValues:t}=n;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map((n=>n.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const a=t.find((n=>n.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:e,tabValues:r}))),[l,c]=f({queryString:t,groupId:a}),[d,g]=function(n){let{groupId:e}=n;const t=function(n){return n?`docusaurus.tab.${n}`:null}(e),[a,r]=(0,u.Nk)(t);return[a,(0,i.useCallback)((n=>{t&&r.set(n)}),[t,r])]}({groupId:a}),b=(()=>{const n=l??d;return m({value:n,tabValues:r})?n:null})();(0,i.useLayoutEffect)((()=>{b&&o(b)}),[b]);return{selectedValue:s,selectValue:(0,i.useCallback)((n=>{if(!m({value:n,tabValues:r}))throw new Error(`Can't select invalid tab value=${n}`);o(n),c(n),g(n)}),[c,g,r]),tabValues:r}}var b=t(2389);const y="tabList__CuJ",k="tabItem_LNqP";function h(n){let{className:e,block:t,selectedValue:o,selectValue:l,tabValues:c}=n;const u=[],{blockElementScrollPositionUntilNextRender:d}=(0,s.o5)(),p=n=>{const e=n.currentTarget,t=u.indexOf(e),a=c[t].value;a!==o&&(d(e),l(a))},m=n=>{let e=null;switch(n.key){case"Enter":p(n);break;case"ArrowRight":{const t=u.indexOf(n.currentTarget)+1;e=u[t]??u[0];break}case"ArrowLeft":{const t=u.indexOf(n.currentTarget)-1;e=u[t]??u[u.length-1];break}}e?.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":t},e)},c.map((n=>{let{value:e,label:t,attributes:s}=n;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:o===e?0:-1,"aria-selected":o===e,key:e,ref:n=>u.push(n),onKeyDown:m,onClick:p},s,{className:(0,r.Z)("tabs__item",k,s?.className,{"tabs__item--active":o===e})}),t??e)})))}function v(n){let{lazy:e,children:t,selectedValue:a}=n;const r=(Array.isArray(t)?t:[t]).filter(Boolean);if(e){const n=r.find((n=>n.props.value===a));return n?(0,i.cloneElement)(n,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},r.map(((n,e)=>(0,i.cloneElement)(n,{key:e,hidden:n.props.value!==a}))))}function _(n){const e=g(n);return i.createElement("div",{className:(0,r.Z)("tabs-container",y)},i.createElement(h,(0,a.Z)({},n,e)),i.createElement(v,(0,a.Z)({},n,e)))}function w(n){const e=(0,b.Z)();return i.createElement(_,(0,a.Z)({key:String(e)},n))}},2385:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>u,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var a=t(7462),i=(t(7294),t(3905)),r=t(4866),s=t(5162);const o={},l="UI",c={unversionedId:"plugins/ui",id:"plugins/ui",title:"UI",description:"bufferline.nvim",source:"@site/docs/plugins/ui.md",sourceDirName:"plugins",slug:"/plugins/ui",permalink:"/plugins/ui",draft:!1,editUrl:"https://github.com/LazyVim/lazyvim.github.io/tree/main/docs/plugins/ui.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"TreeSitter",permalink:"/plugins/treesitter"},next:{title:"Util",permalink:"/plugins/util"}},u={},d=[{value:"bufferline.nvim",id:"bufferlinenvim",level:2},{value:"lualine.nvim",id:"lualinenvim",level:2},{value:"noice.nvim",id:"noicenvim",level:2},{value:"mini.icons",id:"miniicons",level:2},{value:"nui.nvim",id:"nuinvim",level:2},{value:"snacks.nvim",id:"snacksnvim",level:2},{value:"snacks.nvim",id:"snacksnvim-1",level:2},{value:"snacks.nvim",id:"snacksnvim-2",level:2}],p={toc:d};function m(n){let{components:e,...t}=n;return(0,i.kt)("wrapper",(0,a.Z)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"ui"},"UI"),(0,i.kt)("h2",{id:"bufferlinenvim"},(0,i.kt)("a",{parentName:"h2",href:"https://github.com/akinsho/bufferline.nvim"},"bufferline.nvim")),(0,i.kt)("p",null," This is what powers LazyVim's fancy-looking\ntabs, which include filetype icons and close buttons."),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"opts",label:"Options",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'opts = {\n  options = {\n    -- stylua: ignore\n    close_command = function(n) Snacks.bufdelete(n) end,\n    -- stylua: ignore\n    right_mouse_command = function(n) Snacks.bufdelete(n) end,\n    diagnostics = "nvim_lsp",\n    always_show_bufferline = false,\n    diagnostics_indicator = function(_, _, diag)\n      local icons = LazyVim.config.icons.diagnostics\n      local ret = (diag.error and icons.Error .. diag.error .. " " or "")\n        .. (diag.warning and icons.Warn .. diag.warning or "")\n      return vim.trim(ret)\n    end,\n    offsets = {\n      {\n        filetype = "neo-tree",\n        text = "Neo-tree",\n        highlight = "Directory",\n        text_align = "left",\n      },\n      {\n        filetype = "snacks_layout_box",\n      },\n    },\n    ---@param opts bufferline.IconFetcherOpts\n    get_element_icon = function(opts)\n      return LazyVim.config.icons.ft[opts.filetype]\n    end,\n  },\n}\n'))),(0,i.kt)(s.Z,{value:"code",label:"Full Spec",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'{\n  "akinsho/bufferline.nvim",\n  event = "VeryLazy",\n  keys = {\n    { "<leader>bp", "<Cmd>BufferLineTogglePin<CR>", desc = "Toggle Pin" },\n    { "<leader>bP", "<Cmd>BufferLineGroupClose ungrouped<CR>", desc = "Delete Non-Pinned Buffers" },\n    { "<leader>br", "<Cmd>BufferLineCloseRight<CR>", desc = "Delete Buffers to the Right" },\n    { "<leader>bl", "<Cmd>BufferLineCloseLeft<CR>", desc = "Delete Buffers to the Left" },\n    { "<S-h>", "<cmd>BufferLineCyclePrev<cr>", desc = "Prev Buffer" },\n    { "<S-l>", "<cmd>BufferLineCycleNext<cr>", desc = "Next Buffer" },\n    { "[b", "<cmd>BufferLineCyclePrev<cr>", desc = "Prev Buffer" },\n    { "]b", "<cmd>BufferLineCycleNext<cr>", desc = "Next Buffer" },\n    { "[B", "<cmd>BufferLineMovePrev<cr>", desc = "Move buffer prev" },\n    { "]B", "<cmd>BufferLineMoveNext<cr>", desc = "Move buffer next" },\n  },\n  opts = {\n    options = {\n      -- stylua: ignore\n      close_command = function(n) Snacks.bufdelete(n) end,\n      -- stylua: ignore\n      right_mouse_command = function(n) Snacks.bufdelete(n) end,\n      diagnostics = "nvim_lsp",\n      always_show_bufferline = false,\n      diagnostics_indicator = function(_, _, diag)\n        local icons = LazyVim.config.icons.diagnostics\n        local ret = (diag.error and icons.Error .. diag.error .. " " or "")\n          .. (diag.warning and icons.Warn .. diag.warning or "")\n        return vim.trim(ret)\n      end,\n      offsets = {\n        {\n          filetype = "neo-tree",\n          text = "Neo-tree",\n          highlight = "Directory",\n          text_align = "left",\n        },\n        {\n          filetype = "snacks_layout_box",\n        },\n      },\n      ---@param opts bufferline.IconFetcherOpts\n      get_element_icon = function(opts)\n        return LazyVim.config.icons.ft[opts.filetype]\n      end,\n    },\n  },\n  config = function(_, opts)\n    require("bufferline").setup(opts)\n    -- Fix bufferline when restoring a session\n    vim.api.nvim_create_autocmd({ "BufAdd", "BufDelete" }, {\n      callback = function()\n        vim.schedule(function()\n          pcall(nvim_bufferline)\n        end)\n      end,\n    })\n  end,\n}\n')))),(0,i.kt)("h2",{id:"lualinenvim"},(0,i.kt)("a",{parentName:"h2",href:"https://github.com/nvim-lualine/lualine.nvim"},"lualine.nvim")),(0,i.kt)("p",null," statusline"),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"opts",label:"Options",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'opts = function()\n  -- PERF: we don\'t need this lualine require madness \ud83e\udd37\n  local lualine_require = require("lualine_require")\n  lualine_require.require = require\n\n  local icons = LazyVim.config.icons\n\n  vim.o.laststatus = vim.g.lualine_laststatus\n\n  local opts = {\n    options = {\n      theme = "auto",\n      globalstatus = vim.o.laststatus == 3,\n      disabled_filetypes = { statusline = { "dashboard", "alpha", "ministarter", "snacks_dashboard" } },\n    },\n    sections = {\n      lualine_a = { "mode" },\n      lualine_b = { "branch" },\n\n      lualine_c = {\n        LazyVim.lualine.root_dir(),\n        {\n          "diagnostics",\n          symbols = {\n            error = icons.diagnostics.Error,\n            warn = icons.diagnostics.Warn,\n            info = icons.diagnostics.Info,\n            hint = icons.diagnostics.Hint,\n          },\n        },\n        { "filetype", icon_only = true, separator = "", padding = { left = 1, right = 0 } },\n        { LazyVim.lualine.pretty_path() },\n      },\n      lualine_x = {\n        Snacks.profiler.status(),\n        -- stylua: ignore\n        {\n          function() return require("noice").api.status.command.get() end,\n          cond = function() return package.loaded["noice"] and require("noice").api.status.command.has() end,\n          color = function() return { fg = Snacks.util.color("Statement") } end,\n        },\n        -- stylua: ignore\n        {\n          function() return require("noice").api.status.mode.get() end,\n          cond = function() return package.loaded["noice"] and require("noice").api.status.mode.has() end,\n          color = function() return { fg = Snacks.util.color("Constant") } end,\n        },\n        -- stylua: ignore\n        {\n          function() return "\uf46f  " .. require("dap").status() end,\n          cond = function() return package.loaded["dap"] and require("dap").status() ~= "" end,\n          color = function() return { fg = Snacks.util.color("Debug") } end,\n        },\n        -- stylua: ignore\n        {\n          require("lazy.status").updates,\n          cond = require("lazy.status").has_updates,\n          color = function() return { fg = Snacks.util.color("Special") } end,\n        },\n        {\n          "diff",\n          symbols = {\n            added = icons.git.added,\n            modified = icons.git.modified,\n            removed = icons.git.removed,\n          },\n          source = function()\n            local gitsigns = vim.b.gitsigns_status_dict\n            if gitsigns then\n              return {\n                added = gitsigns.added,\n                modified = gitsigns.changed,\n                removed = gitsigns.removed,\n              }\n            end\n          end,\n        },\n      },\n      lualine_y = {\n        { "progress", separator = " ", padding = { left = 1, right = 0 } },\n        { "location", padding = { left = 0, right = 1 } },\n      },\n      lualine_z = {\n        function()\n          return "\uf43a " .. os.date("%R")\n        end,\n      },\n    },\n    extensions = { "neo-tree", "lazy", "fzf" },\n  }\n\n  -- do not add trouble symbols if aerial is enabled\n  -- And allow it to be overriden for some buffer types (see autocmds)\n  if vim.g.trouble_lualine and LazyVim.has("trouble.nvim") then\n    local trouble = require("trouble")\n    local symbols = trouble.statusline({\n      mode = "symbols",\n      groups = {},\n      title = false,\n      filter = { range = true },\n      format = "{kind_icon}{symbol.name:Normal}",\n      hl_group = "lualine_c_normal",\n    })\n    table.insert(opts.sections.lualine_c, {\n      symbols and symbols.get,\n      cond = function()\n        return vim.b.trouble_lualine ~= false and symbols.has()\n      end,\n    })\n  end\n\n  return opts\nend\n'))),(0,i.kt)(s.Z,{value:"code",label:"Full Spec",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'{\n  "nvim-lualine/lualine.nvim",\n  event = "VeryLazy",\n  init = function()\n    vim.g.lualine_laststatus = vim.o.laststatus\n    if vim.fn.argc(-1) > 0 then\n      -- set an empty statusline till lualine loads\n      vim.o.statusline = " "\n    else\n      -- hide the statusline on the starter page\n      vim.o.laststatus = 0\n    end\n  end,\n  opts = function()\n    -- PERF: we don\'t need this lualine require madness \ud83e\udd37\n    local lualine_require = require("lualine_require")\n    lualine_require.require = require\n\n    local icons = LazyVim.config.icons\n\n    vim.o.laststatus = vim.g.lualine_laststatus\n\n    local opts = {\n      options = {\n        theme = "auto",\n        globalstatus = vim.o.laststatus == 3,\n        disabled_filetypes = { statusline = { "dashboard", "alpha", "ministarter", "snacks_dashboard" } },\n      },\n      sections = {\n        lualine_a = { "mode" },\n        lualine_b = { "branch" },\n\n        lualine_c = {\n          LazyVim.lualine.root_dir(),\n          {\n            "diagnostics",\n            symbols = {\n              error = icons.diagnostics.Error,\n              warn = icons.diagnostics.Warn,\n              info = icons.diagnostics.Info,\n              hint = icons.diagnostics.Hint,\n            },\n          },\n          { "filetype", icon_only = true, separator = "", padding = { left = 1, right = 0 } },\n          { LazyVim.lualine.pretty_path() },\n        },\n        lualine_x = {\n          Snacks.profiler.status(),\n          -- stylua: ignore\n          {\n            function() return require("noice").api.status.command.get() end,\n            cond = function() return package.loaded["noice"] and require("noice").api.status.command.has() end,\n            color = function() return { fg = Snacks.util.color("Statement") } end,\n          },\n          -- stylua: ignore\n          {\n            function() return require("noice").api.status.mode.get() end,\n            cond = function() return package.loaded["noice"] and require("noice").api.status.mode.has() end,\n            color = function() return { fg = Snacks.util.color("Constant") } end,\n          },\n          -- stylua: ignore\n          {\n            function() return "\uf46f  " .. require("dap").status() end,\n            cond = function() return package.loaded["dap"] and require("dap").status() ~= "" end,\n            color = function() return { fg = Snacks.util.color("Debug") } end,\n          },\n          -- stylua: ignore\n          {\n            require("lazy.status").updates,\n            cond = require("lazy.status").has_updates,\n            color = function() return { fg = Snacks.util.color("Special") } end,\n          },\n          {\n            "diff",\n            symbols = {\n              added = icons.git.added,\n              modified = icons.git.modified,\n              removed = icons.git.removed,\n            },\n            source = function()\n              local gitsigns = vim.b.gitsigns_status_dict\n              if gitsigns then\n                return {\n                  added = gitsigns.added,\n                  modified = gitsigns.changed,\n                  removed = gitsigns.removed,\n                }\n              end\n            end,\n          },\n        },\n        lualine_y = {\n          { "progress", separator = " ", padding = { left = 1, right = 0 } },\n          { "location", padding = { left = 0, right = 1 } },\n        },\n        lualine_z = {\n          function()\n            return "\uf43a " .. os.date("%R")\n          end,\n        },\n      },\n      extensions = { "neo-tree", "lazy", "fzf" },\n    }\n\n    -- do not add trouble symbols if aerial is enabled\n    -- And allow it to be overriden for some buffer types (see autocmds)\n    if vim.g.trouble_lualine and LazyVim.has("trouble.nvim") then\n      local trouble = require("trouble")\n      local symbols = trouble.statusline({\n        mode = "symbols",\n        groups = {},\n        title = false,\n        filter = { range = true },\n        format = "{kind_icon}{symbol.name:Normal}",\n        hl_group = "lualine_c_normal",\n      })\n      table.insert(opts.sections.lualine_c, {\n        symbols and symbols.get,\n        cond = function()\n          return vim.b.trouble_lualine ~= false and symbols.has()\n        end,\n      })\n    end\n\n    return opts\n  end,\n}\n')))),(0,i.kt)("h2",{id:"noicenvim"},(0,i.kt)("a",{parentName:"h2",href:"https://github.com/folke/noice.nvim"},"noice.nvim")),(0,i.kt)("p",null," Highly experimental plugin that completely replaces the UI for messages, cmdline and the popupmenu."),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"opts",label:"Options",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'opts = {\n  lsp = {\n    override = {\n      ["vim.lsp.util.convert_input_to_markdown_lines"] = true,\n      ["vim.lsp.util.stylize_markdown"] = true,\n      ["cmp.entry.get_documentation"] = true,\n    },\n  },\n  routes = {\n    {\n      filter = {\n        event = "msg_show",\n        any = {\n          { find = "%d+L, %d+B" },\n          { find = "; after #%d+" },\n          { find = "; before #%d+" },\n        },\n      },\n      view = "mini",\n    },\n  },\n  presets = {\n    bottom_search = true,\n    command_palette = true,\n    long_message_to_split = true,\n  },\n}\n'))),(0,i.kt)(s.Z,{value:"code",label:"Full Spec",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'{\n  "folke/noice.nvim",\n  event = "VeryLazy",\n  opts = {\n    lsp = {\n      override = {\n        ["vim.lsp.util.convert_input_to_markdown_lines"] = true,\n        ["vim.lsp.util.stylize_markdown"] = true,\n        ["cmp.entry.get_documentation"] = true,\n      },\n    },\n    routes = {\n      {\n        filter = {\n          event = "msg_show",\n          any = {\n            { find = "%d+L, %d+B" },\n            { find = "; after #%d+" },\n            { find = "; before #%d+" },\n          },\n        },\n        view = "mini",\n      },\n    },\n    presets = {\n      bottom_search = true,\n      command_palette = true,\n      long_message_to_split = true,\n    },\n  },\n  -- stylua: ignore\n  keys = {\n    { "<leader>sn", "", desc = "+noice"},\n    { "<S-Enter>", function() require("noice").redirect(vim.fn.getcmdline()) end, mode = "c", desc = "Redirect Cmdline" },\n    { "<leader>snl", function() require("noice").cmd("last") end, desc = "Noice Last Message" },\n    { "<leader>snh", function() require("noice").cmd("history") end, desc = "Noice History" },\n    { "<leader>sna", function() require("noice").cmd("all") end, desc = "Noice All" },\n    { "<leader>snd", function() require("noice").cmd("dismiss") end, desc = "Dismiss All" },\n    { "<leader>snt", function() require("noice").cmd("pick") end, desc = "Noice Picker (Telescope/FzfLua)" },\n    { "<c-f>", function() if not require("noice.lsp").scroll(4) then return "<c-f>" end end, silent = true, expr = true, desc = "Scroll Forward", mode = {"i", "n", "s"} },\n    { "<c-b>", function() if not require("noice.lsp").scroll(-4) then return "<c-b>" end end, silent = true, expr = true, desc = "Scroll Backward", mode = {"i", "n", "s"}},\n  },\n  config = function(_, opts)\n    -- HACK: noice shows messages from before it was enabled,\n    -- but this is not ideal when Lazy is installing plugins,\n    -- so clear the messages in this case.\n    if vim.o.filetype == "lazy" then\n      vim.cmd([[messages clear]])\n    end\n    require("noice").setup(opts)\n  end,\n}\n')))),(0,i.kt)("h2",{id:"miniicons"},(0,i.kt)("a",{parentName:"h2",href:"https://github.com/echasnovski/mini.icons"},"mini.icons")),(0,i.kt)("p",null," icons"),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"opts",label:"Options",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'opts = {\n  file = {\n    [".keep"] = { glyph = "\udb80\udea2", hl = "MiniIconsGrey" },\n    ["devcontainer.json"] = { glyph = "\uf4b7", hl = "MiniIconsAzure" },\n  },\n  filetype = {\n    dotenv = { glyph = "\ueb52", hl = "MiniIconsYellow" },\n  },\n}\n'))),(0,i.kt)(s.Z,{value:"code",label:"Full Spec",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'{\n  "echasnovski/mini.icons",\n  lazy = true,\n  opts = {\n    file = {\n      [".keep"] = { glyph = "\udb80\udea2", hl = "MiniIconsGrey" },\n      ["devcontainer.json"] = { glyph = "\uf4b7", hl = "MiniIconsAzure" },\n    },\n    filetype = {\n      dotenv = { glyph = "\ueb52", hl = "MiniIconsYellow" },\n    },\n  },\n  init = function()\n    package.preload["nvim-web-devicons"] = function()\n      require("mini.icons").mock_nvim_web_devicons()\n      return package.loaded["nvim-web-devicons"]\n    end\n  end,\n}\n')))),(0,i.kt)("h2",{id:"nuinvim"},(0,i.kt)("a",{parentName:"h2",href:"https://github.com/MunifTanjim/nui.nvim"},"nui.nvim")),(0,i.kt)("p",null," ui components"),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"opts",label:"Options",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"opts = nil\n"))),(0,i.kt)(s.Z,{value:"code",label:"Full Spec",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'{ "MunifTanjim/nui.nvim", lazy = true }\n')))),(0,i.kt)("h2",{id:"snacksnvim"},(0,i.kt)("a",{parentName:"h2",href:"https://github.com/folke/snacks.nvim"},"snacks.nvim")),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"opts",label:"Options",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"opts = {\n  indent = { enabled = true },\n  input = { enabled = true },\n  notifier = { enabled = true },\n  scope = { enabled = true },\n  scroll = { enabled = true },\n  statuscolumn = { enabled = false }, -- we set this in options.lua\n  toggle = { map = LazyVim.safe_keymap_set },\n  words = { enabled = true },\n}\n"))),(0,i.kt)(s.Z,{value:"code",label:"Full Spec",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'{\n  "snacks.nvim",\n  opts = {\n    indent = { enabled = true },\n    input = { enabled = true },\n    notifier = { enabled = true },\n    scope = { enabled = true },\n    scroll = { enabled = true },\n    statuscolumn = { enabled = false }, -- we set this in options.lua\n    toggle = { map = LazyVim.safe_keymap_set },\n    words = { enabled = true },\n  },\n  -- stylua: ignore\n  keys = {\n    { "<leader>n", function()\n      if Snacks.config.picker and Snacks.config.picker.enabled then\n        Snacks.picker.notifications()\n      else\n        Snacks.notifier.show_history()\n      end\n    end, desc = "Notification History" },\n    { "<leader>un", function() Snacks.notifier.hide() end, desc = "Dismiss All Notifications" },\n  },\n}\n')))),(0,i.kt)("h2",{id:"snacksnvim-1"},(0,i.kt)("a",{parentName:"h2",href:"https://github.com/folke/snacks.nvim"},"snacks.nvim")),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"opts",label:"Options",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'opts = {\n   dashboard = {\n     preset = {\n       pick = function(cmd, opts)\n         return LazyVim.pick(cmd, opts)()\n       end,\n       header = [[\n       \u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557          Z\n       \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551      Z    \n       \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551  \u2588\u2588\u2588\u2554\u255d  \u255a\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551   z       \n       \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551 \u2588\u2588\u2588\u2554\u255d    \u255a\u2588\u2588\u2554\u255d  \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551 z         \n       \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551    \u255a\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551           \n       \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d     \u255a\u2550\u2550\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d           \n]],\n       -- stylua: ignore\n       ---@type snacks.dashboard.Item[]\n       keys = {\n         { icon = "\uf002 ", key = "f", desc = "Find File", action = ":lua Snacks.dashboard.pick(\'files\')" },\n         { icon = "\uf15b ", key = "n", desc = "New File", action = ":ene | startinsert" },\n         { icon = "\uf022 ", key = "g", desc = "Find Text", action = ":lua Snacks.dashboard.pick(\'live_grep\')" },\n         { icon = "\uf0c5 ", key = "r", desc = "Recent Files", action = ":lua Snacks.dashboard.pick(\'oldfiles\')" },\n         { icon = "\uf423 ", key = "c", desc = "Config", action = ":lua Snacks.dashboard.pick(\'files\', {cwd = vim.fn.stdpath(\'config\')})" },\n         { icon = "\ue348 ", key = "s", desc = "Restore Session", section = "session" },\n         { icon = "\uea8c ", key = "x", desc = "Lazy Extras", action = ":LazyExtras" },\n         { icon = "\udb81\udcb2 ", key = "l", desc = "Lazy", action = ":Lazy" },\n         { icon = "\uf426 ", key = "q", desc = "Quit", action = ":qa" },\n       },\n     },\n   },\n }\n'))),(0,i.kt)(s.Z,{value:"code",label:"Full Spec",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'{\n  "snacks.nvim",\n  opts = {\n    dashboard = {\n      preset = {\n        pick = function(cmd, opts)\n          return LazyVim.pick(cmd, opts)()\n        end,\n        header = [[\n        \u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557          Z\n        \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551      Z    \n        \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551  \u2588\u2588\u2588\u2554\u255d  \u255a\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551   z       \n        \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551 \u2588\u2588\u2588\u2554\u255d    \u255a\u2588\u2588\u2554\u255d  \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551 z         \n        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551    \u255a\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551           \n        \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d     \u255a\u2550\u2550\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d           \n ]],\n        -- stylua: ignore\n        ---@type snacks.dashboard.Item[]\n        keys = {\n          { icon = "\uf002 ", key = "f", desc = "Find File", action = ":lua Snacks.dashboard.pick(\'files\')" },\n          { icon = "\uf15b ", key = "n", desc = "New File", action = ":ene | startinsert" },\n          { icon = "\uf022 ", key = "g", desc = "Find Text", action = ":lua Snacks.dashboard.pick(\'live_grep\')" },\n          { icon = "\uf0c5 ", key = "r", desc = "Recent Files", action = ":lua Snacks.dashboard.pick(\'oldfiles\')" },\n          { icon = "\uf423 ", key = "c", desc = "Config", action = ":lua Snacks.dashboard.pick(\'files\', {cwd = vim.fn.stdpath(\'config\')})" },\n          { icon = "\ue348 ", key = "s", desc = "Restore Session", section = "session" },\n          { icon = "\uea8c ", key = "x", desc = "Lazy Extras", action = ":LazyExtras" },\n          { icon = "\udb81\udcb2 ", key = "l", desc = "Lazy", action = ":Lazy" },\n          { icon = "\uf426 ", key = "q", desc = "Quit", action = ":qa" },\n        },\n      },\n    },\n  },\n}\n')))),(0,i.kt)("h2",{id:"snacksnvim-2"},(0,i.kt)("a",{parentName:"h2",href:"https://github.com/folke/snacks.nvim"},"snacks.nvim")),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"opts",label:"Options",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'opts = function(_, opts)\n  if not opts.picker then\n    return\n  end\n  table.insert(opts.dashboard.preset.keys, 3, {\n    icon = "\uf502 ",\n    key = "p",\n    desc = "Projects",\n    action = ":lua Snacks.picker.projects()",\n  })\nend\n'))),(0,i.kt)(s.Z,{value:"code",label:"Full Spec",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'{\n  "folke/snacks.nvim",\n  opts = function(_, opts)\n    if not opts.picker then\n      return\n    end\n    table.insert(opts.dashboard.preset.keys, 3, {\n      icon = "\uf502 ",\n      key = "p",\n      desc = "Projects",\n      action = ":lua Snacks.picker.projects()",\n    })\n  end,\n}\n')))))}m.isMDXComponent=!0}}]);